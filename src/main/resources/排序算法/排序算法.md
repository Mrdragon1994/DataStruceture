# 基本介绍
1、排序其实是一种算法，将一组数据依据指定的顺序进行排列的过成；
2、分类
2.1、内部排序
将需要处理的数据加载到内存中,在内存中完成排序；
2.2、外部排序
如果数据量很大,无法将所有数据全部加载到内存中,需要借助外部存储进行排序。
其中，内部排序分为：插入排序(直接插入排序,希尔排序);选择排序(简单选择排序,堆排序);交换排序(冒泡排序,快速排序);归并排序;基数排序(桶排序)

# 算法的时间复杂度
1、事后统计法
先运行程序，在看花费的时间;但是很取决于计算机性能;需要在同一个计算机的相同状态下运行程序；
2、事前估算法
通过分析某个算法的时间复杂度来判断哪个算法更优秀。
时间频度：一个算法中语句执行的次数称为语句频度或时间频度，记为T(n)
时间复杂度:忽略常数项,忽略低次项,忽略系数

1、一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，记O(f(n))为算法的渐进时间复杂度,简称时间复杂度;
2、T(n)不同,但时间复杂度可能相同,如:T(n)=n^2+7n+6和T(n)=3n^2+2n+2,它们的T(n)不同，但是他们的渐进时间复杂度f(n)均为n^2,因此两者
的时间复杂度O(n)=n^2;
3、计算时间复杂度：用常数1替换运算时间中的所有加法常数；修改替换后的常数,只保留最高阶项;去除最高阶项的系数
如：T(n)=2n^2+7n+6 -> T(n)=2n^2+7n+1 -> T(n)=2n^2 -> T(n)=n^2
4、常见的事件复杂度
常数阶：O(1)
对数阶: O(log2n)
线性阶：O(n)
线性对数阶：O(nlog2n)
平方阶：O(n^2)
立方阶：O(n^3)
K次方阶：O(n^k)
指数阶：O(2^n)

1) 常数阶O(1)
无论代码执行了多少行,只要没有循环等复杂结构,那么代码的时间复杂度就是O(1)
2) 对数阶O(log2n)
    `int i = 1;
    while (i < n) {
        i = i * 2
    }`
3) 线性阶O(n)
   `int j = 0;
    IntStream.rangeClosed(i, n).forEach(i -> {
            j = i;
            j++;
        })`
4) 线性对数阶O(nlog2n)
    `for (m = 1; m < n; m++) {
        int i = 1;
        while (i < n) {
               i = i * 2;
            }
        }`
5) 平方阶O(n^2)
   ` int k = 0;
    IntStream(1, n).forEach(i -> {
            IntStream(1, n).forEach(
                j -> {
                    k = i;
                    k++;    
                }
            )
        }) `

# 平均时间复杂度和最坏时间复杂度
通常情况下我们讨论的是最坏时间复杂度

# 算法的空间复杂度
空间复杂度对一个算法在一个运行过程中临时占用存储空间大小的量度;在做算法分析时,时间复杂度优先考虑。
一些缓存产品(redis,memcache)和基数排序本质就是用空间换时间。



