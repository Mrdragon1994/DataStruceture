# 基本知识
1）、链表是由多个节点组成的，每个节点由data域和next域构成，data域是用来存储数据的，next域是指向下一个节点的；
2）、链表的各个节点不一定是连续存储的；
3）、链表分带头结点的链表和 没有头结点的链表，根据实际需求确定。
# 带头结点的单向链表
1）、头结点不放具体的数据，作用就是表示单链表的表头
2）、添加（创建）的流程：
    先创建一个头结点，作用就是表示单链表的头；
    后面每添加一个节点，就直接加入到链表的最后，
    遍历：
    通过一个辅助指针，帮助我们遍历整个单链表；

# 按照编号的大小顺序添加节点
1、首先找到新添加节点的位置，是通过辅助变量（指针）来寻找的；
2、让新的节点.next = temp.next
3、temp.next = 新的节点.next

# 删除单向链表的节点（单向找上一个，双向找本身）
1、通过一个辅助变量（指针），找到待删除节点的上一个节点
2、temp.next = temp.next.next

# 单链表反转的思路
1、先定义一个节点reverseHead = new HeroNode
2、从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表的最前端(采用头插法插入)
3、将原来链表的头结点head.next = reverseHead.next

# 双向链表
## 单向链表的缺点
1.单向链表查找的时候只能是一个方向，而双向链表可以向前或向后查找；
2.单向链表不能自我删除，需要依赖辅助节点，而双向链表可以自我删除; 单向链表删除时，需要借助一个temp,待删除节点的前一个节点。

## 双向链表的查找/遍历
和单向链表一样，可以向前，也可以向后

## 双向链表的添加(默认添加到最后)
1.先找到双向链表的最后temp;
2.让temp.next = newHeroNode
3.newHeroNode.pre = temp;

## 双向链表的修改
思路和原来的单向链表一样

## 双向链表的删除
1.因为是双向链表，因此可以实现自我删除某个节点;
2.直接找到要删除的这个节点temp；
3.temp.pre.next = temp.next;
4.temp.next.pre = temp.pre;


 
